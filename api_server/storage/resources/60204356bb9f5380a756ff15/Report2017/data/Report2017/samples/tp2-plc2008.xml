<?xml version="1.0" encoding="ISO-8859-1"?>
<r:report xmlns:r="http://xml.di.uminho.pt/report2007"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://xml.di.uminho.pt/report2007 report.xsd"
	xmlns:p="http://xml.di.uminho.pt/paragraph2007">
	<frontmatter>
		<title>Trabalho Prático II</title>
		<subtitle>Processamento de Linguagens e Compiladores (PLC2008)</subtitle>
		<authors>
			<author>
				<name>José Carlos Ramalho</name>
			</author>
			<author>
				<name>José João Almeida</name>
			</author>
		</authors>
		<dates>
			<date>
				<value>2008-05-07</value>
				<description>Criada a segunda versão com o segundo enunciado completo.</description>
			</date>
			
			<date>
				<value>2008-04-22</value>
				<description>Criada a primeira versão.</description>
			</date>
		</dates>
		<keywords>
			<kw>Compiladores</kw>
			<kw>Trabalho Prático</kw>
			<kw>C</kw>
			<kw>Lex</kw>
			<kw>Yacc</kw>
		</keywords>
		<abstract>
			<p:p>Este documento descreve os vários temas disponiveis para a realização do trabalho
				prático que os alunos a fazer a disciplina em epígrafe têm de realizar de forma a
				obter uma avaliação prática à disciplina.</p:p>
			<p:p><b>Ao longo de várias semanas, irá evoluindo e sofrendo alterações.</b> Esteja atento às
				datas de revisões e aos comentários sobre as alterações introduzidas.</p:p>
			<p:p>Dos vários enunciados disponiveis, cada grupo de trabalho deverá escolher um que
			desenvolverá e submeterá para avaliação no fim do semestre.</p:p>
			<p:p>Este trabalho vale 2/3 da nota prática.</p:p>
		</abstract>
		<toc/>
	</frontmatter>
	<body>
		<chapter>
			<title>Objectivos de formação e resultados de aprendizagem</title>
			<p:p>Este projecto tem como objectivos principais a formação genérica e específica de
				estudantes em fundamentos de computação na área do processamento de linguagens. </p:p>
			<p:p>Os objectivos de formação genérica incluem: (i) a pesquisa, análise e selecção de
				informação, (ii) o treino na resolução de problemas, (iii) o desenvolvimento da
				capacidade de análise, e (iv) o desenvolvimento da capacidade de comunicação escrita
				e oral. </p:p>
			<p:p>Os objectivos de formação específica incluem: (i) a análise da especificação e do
				problema, (ii) o desenvolvimento de algoritmos e consequente programação numa
				linguagem imperativa, (iii) a execução e realização de testes de conformidade. </p:p>
			<p:p>A avaliação dos resultados esperados de aprendizagem irão verificar se as/os
				estudantes conseguem demonstrar ter adquirido o seguinte conjunto de competências
				genéricas e específicas:</p:p>
			<ulist>
				<item>competências genéricas<ulist>
						<item>a capacidade de comunicação escrita e oral na apresentação e discussão
							dos processos usados e resultados obtidos;</item>
						<item>a capacidade de utilização de utilitários genéricos de informática em
							ambiente Linux e de elaboração de documentos anotados</item>
					</ulist>
				</item>
				<item>competências específicas de Processamento de Linguagens<ulist>
						<item>a capacidade de especificar gramáticas que modelem determinados
							problemas, de forma criativa, criteriosa e crítica</item>
						<item>o conhecimento e a capacidade para implementar reconhecedores léxicos
							e sintácticos para uma determinada especificação gramatical fornecida</item>
						<item>a capacidade para detectar e resolver conflitos em especificações
							gramaticais</item>
						<item>a capacidade e o conhecimento para acrescentar acções semânticas aos
							reconhecedores desenvolvidos</item>
						<item>o conhecimento e a capacidade de codificar algoritmos e estruturas de
							dados segundo os princípios da programação estruturada</item>
						<item>a capacidade e aptidões práticas para gerar, executar e testar
							programas codificados em C, usando um conjunto adequado de utilitários
							(GNU)</item>
						<item>o conhecimento e as aptidões de desenvolver e aplicar testes de
							conformidade e de analisar situações de fronteira na execução de
							programas</item>
						<item>capacidade e aptidões na produção de documentação adequada à
							manutenção por terceiros dos programas desenvolvidos</item>
					</ulist>
				</item>
			</ulist>
		</chapter>
		<chapter>
			<title>Enunciado 1 - Report2007: vamos escrever relatórios</title>
			<p:p>A escrita de relatórios técnicos é muito importante no contexto em que te estás a
				inserir.</p:p>
			<p:p>Neste projecto, irás desenvolver um compilador que aceitará relatórios escritos
				numa determinada linguagem e gerará a respectiva versão HTML (como extra poderá
				gerar também uma versão em LaTeX).</p:p>
			<p:p>A especificação da gramática da linguagem para a escrita de relatórios é dada
				abaixo (com alguns pormenores em branco). Deverás analisá-la, completá-la e
				implementá-la.</p:p>
			<p:p>Na análise da gramática tem em conta as seguintes considerações:</p:p>
			<ulist>
				<item>Símbolos capitalizados pertencem à família dos não-terminais: Report, Abstract, TRowList, ...;</item>
				<item>Símbolos em maiúsculas pertencem à família dos terminais constantes (palavras reservadas ou símbolos carácter): BTITLE, EGRAPH, ...;</item>
				<item>Símbolos em minúsculas pertencem à família dos terminais variáveis: texto, path, ...;</item>
				<item>A definição de cada símbolo terminal ficará a seu cargo, a gramática apenas indica onde eles deverão aparecer (seja imaginativo,
				proponha alterações, ...);</item>
				<item>Os não terminais marcados com "?" são opcionais e deverão ser tratados à
				semelhança de "SubTitle".</item>
				<item>Como é suposto utilizarem o <inlinecode>yacc</inlinecode> para implementarem o compilador a gramática foi escrita com recursividade 
				à esquerda, alterem-na se optarem por uma metodologia de <i>parsing Top-Down</i>.</item>
			</ulist>
			<p:p>Um Relatório é composto por 3 partes: uma parte inicial, um corpo e uma parte final.</p:p>
			<codeblock>Report --> BREPORT FrontMatter Body BackMatter EREPORT</codeblock>
			
			<p:p>A parte inicial é constituída por um título, um subtítulo opcional, uma lista de autores, uma data, a indicação de uma instituição
			opcional, uma lista de palavras-chave opcional, um resumo, uma secção opcional de agradecimentos, um índice opcional, um índice de 
			figuras opcional e m índice de tabelas opcional.</p:p>
			<codeblock>FrontMatter --> BFM Title SubTitle? Authors Date Institution? Keywords?
                Abstract Aknowledgements? Toc? Lof? Lot? EFM</codeblock>
			<codeblock>Title --> BTITLE texto ETITLE

SubTitle --> BSUBTITLE texto ESUBTITLE 
           | &amp;
			
Authors --> Authors Author 
          | Author
			
Author --> BAUTHOR Name Nident? Email? Url? Affilliation? EAUTHOR
			
			Name --> BNAME texto ENAME</codeblock>
			
			<p:p>O resumo e a secção de agradecimentos são constituídos por uma lista de parágrafos.</p:p>
			
			<codeblock>Abstract --> BABS ParaList EABS
Aknowledgements --> BAKN ParaList EAKN</codeblock>
			<codeblock>Toc --> TOC | &amp;
Lof --> LOF | &amp;
Lot --> LOT | &amp;</codeblock>
			
			<p:p>O Corpo do Relatório é constituído por uma lista de capítulos e um capítulo, por sua vez, é constituído por um título e uma lista de elementos..</p:p>
			
			<codeblock>Body --> BBODY ChapterList EBODY
			
ChapterList --> ChapterList Chapter
              | Chapter
			
Chapter --> BCHAP Title ElemList ECHAP</codeblock>
<p:p>Uma Secção tem um modelo semelhante ao do capítulo só que em vez do subelemento <inlinecode>Section</inlinecode> tem o subelemento 
<inlinecode>SubSection</inlinecode> (o mesmo acontecerá com a <inlinecode>SubSection</inlinecode> e a <inlinecode>SubSubSection</inlinecode>).
</p:p>
			<codeblock>Section --> BSEC Title ElemListSec ESEC</codeblock>
			<codeblock>ElemList --> ElemList Elem
| Elem</codeblock>
			
<p:p>Um elemento pode ser um parágrafo, um elemento <i>flutuante</i> (tabela ou figura), uma lista (descritiva, de itens ou numerada), um bloco 
	de código, uma secção, um sumário.</p:p>			
			
			<codeblock>Elem --> Paragraph
| Float
| List
| CodeBlock
| Section
| Summary</codeblock>
			<p:p>O parágrafo tem um conteúdo composto por texto onde podem aparecer livremente alguns elementos: referências, pedaços de texto com diferentes características 
			de formatação (bold, itálico, ...), acrónimos, ...</p:p>
			<codeblock>Paragraph --> BPARA ParaContent EPARA</codeblock>
			<codeblock>ParaContent --> ParaContent texto
| ParaContent FreeElement
| &amp;</codeblock>
			<codeblock>FreeElement --> Footnote
              | Ref
              | Xref
              | Citref
              | Iterm
              | Bold
              | Italic
              | Underline
              | InlineCode
              | Acronym
			
Ref --> BREF target EREF

Xref --> BXREF target EXREF

Citref --> BCIT target ECIT

Iterm --> BITERM texto EITERM

Bold --> BBOLD BContent EBOLD

BContent --> BContent texto
           | BContent Italic
           | BContent Underline
           | &amp;
           
Italic --> BITALIC IContent EITALIC

IContent --> IContent texto
           | IContent Bold
           | IContent Underline
           | &amp;
           
Underline --> BUNDERLINE UContent EUNDERLINE

UContent --> UContent texto
           | UContent Bold
           | UContent Italic
           | &amp;</codeblock>

			<codeblock>Float --> Figure | Table
				
Figure --> BFIG Graphic Caption EFIG

Graphic --> BGRAPH path format? EGRAPH

Caption --> BCAPTION texto ECAPTION

Table --> BTABLE Caption TRowList

TRowList --> TRowList TRow
           | TRow</codeblock>
		</chapter>
		<chapter>
			<title>Enunciado 2 - XML WorkBench</title>
			<p:p>Neste projecto, pretende-se desenvolver uma plataforma para manipulação de documentos XML.</p:p>
			<p:p>Esta plataforma terá dois níveis: num primeiro nível é preciso reconhecer um documento XML e construir uma sua
			representação em memória; num segundo nível pretende-se generalizar permitindo o carregamento de vários documentos para memória
			sobre os quais se poderão fazer várias operações: selecção de partes, geração de novos documentos a partir dos que estão 
			carregados, estatísticas, ...</p:p>
			<p:p>Podemos dividir este enunciado em 3 partes que se descrevem nas secções seguintes.</p:p>
			<section>
				<title>Reconhecedor de Documentos Estruturados</title>
				<p:p>Como já foi referido, nesta fase o alunos deverá desenvolver um parser que valide um documento XML e crie em memória uma
				representação do mesmo.</p:p>
				<p:p>A título apenas de exemplo apresenta-se uma possível gramática para um documento XML:</p:p>
				<codeblock>Documento --> ElemList '$'
					
ElemList --> ElemList Elem
           | Elem
					
Elem  --> char
        | '&amp;' id ';'
        | '&lt;' id AttrList '&gt;' ElemList '&lt;' '/' id '&gt;'
        | '&lt;' id AttrList '/' '&gt;' 
							
AttrList  --> Attr AttrList
            | &amp;
							
Attr      --> id '=' valor</codeblock>
				<p:p>No reconhecimento do documento, o parser desenvolvido deverá verificar os seguintes invariantes:</p:p>
				<olist>
					<item>todas as anotações correspondentes a elementos com conteúdo são abertas e fechadas correctamente (não há marcas 
						cruzadas);</item>
					<item>o documento tem que obrigatoriamente começar com a abertura dum elemento (que irá englobar todo o documento).</item>
				</olist>
				
			</section>
			<section>
				<title>Interpretador de Comandos</title>
				<p:p>O parser desenvolvido no ponto anterior será uma peça de algo bem maior: o tal <i>"XML Workbench"</i>.</p:p>
				<p:p>Pretende-se agora criar um ambiente de trabalho que aceite os seguintes comandos:</p:p>
				<dlist>
					<dt>LOAD "path para o documento" id</dt>
					<dd>Este comando irá usar o parser desenvolvido no ponto anterior para reconhecer e carregar um documento XML. No fim, 
						deverá ainda criar uma entrada numa estrutura de dados interna em que o identificador <inlinecode>id</inlinecode> 
						fica associado ao documento reconhecido;</dd>
					<dt>LIST</dt>
					<dd>Mostra no écran a lista de documentos carregados e respectivos ids;</dd>
					<dt>SHOW id</dt>
					<dd>Mostra no écran o documento associado ao identificador id em formato ESIS;</dd>
					<dt>EXIT</dt>
					<dd>Sai do programa;</dd>
					<dt>HELP</dt>
					<dd>Imprime no écran um texto parecido com esta lista de comandos.</dd>
				</dlist>
				<p:p>Pode usar a imaginação à vontade para acrescentar comandos a esta lista.</p:p>
				<p:p>Considere ainda a seguinte gramática proposta para este interpretador (pode alterá-la à vontade):</p:p>
				<codeblock>Interp --> ComList
					
ComList --> Comando | ComList Comando
					
Comando --> LOAD fich-id id
          | SHOW id
          | LIST
          | EXIT
          | HELP </codeblock>
			</section>
			<section>
				<title>Document Query Language</title>
				<p:p>Neste momento, todos grupos de trabalho deverã estar munidos dum interpretador de comandos que permite carregar documentos,
				visualizá-los, fornecendo assim um primeiro conjunto de facilidades básicas num sistema documental.</p:p>
				<p:p>Nesta fase, vamos adicionar um novo comando à lista dos já existentes:</p:p>
				<codeblock>QLE: [selector de documentos] [query-exp]
					
[selector de documentos] --> *  "todos os docs carregados"
                           | id "apenas o doc com ident=id"
                           | id1,id2,...,idn
					
[query-exp] --> "definida mais à frente"</codeblock>
				<p:p>O resto do enunciado irá descrever através da apresentação de exemplos as várias facetas das expressões de query que se 
				pretendem suportar.</p:p>
				<subsection>
					<title>Interrogando os Documentos</title>
					<p:p>A operação de seleccionar os elementos com os quais se quer fazer alguma coisa, ou aos quais se quer aplicar algum 
						processamento, tem sido, desde há algum tempo, uma preocupação das pessoas que trabalham nesta área. Começou por surgir 
						na transformação e na formatação: era preciso seleccionar os elementos que se queriam transformar, ou que se queriam 
						mapear num ou mais objectos com características gráficas (formatação). Este esforço é visível no DSSSL <citref target="Cla96"/>; o 
						primeiro elemento das suas regras é uma expressão de "query" que selecciona os elementos aos quais será aplicado o 
						processamento especificado. Por último, esta necessidade surgiu ligada às linguagens de "query" para documentos 
						estruturados, como as que foram propostas na conferência dedicada a esse tópico <citref target="RLS98"/><citref target="DeR98"/>
						<citref target="Tom98"/><citref target="Wid98"/><citref target="CCDFPT98"/>.</p:p>
					<p:p>Assim se chegou, rapidamente, à conclusão de que a operação de selecção necessária para a transformação ou formatação era muito 
					semelhante à necessária nos sistemas de bases de dados documentais para a realização de "queries".</p:p>
					<p:p>Depois de algum tempo de discussão (moderada pelo W3C - World Wide Web Consortium), começa a emergir algum consenso na utilização do 
						XSLT <citref target="XSLT"/>, uma sublinguagem de padrões presente no XSL <citref target="XSL"/> - a proposta de normalização para a 
						especificação de estilos a associar a documentos XML. O XSLT tornou-se um standard e foi já alvo de um estudo formal por parte de Wadler 
						<citref target="Wad99"/>, apresentado na conferência mundial da área ("Markup Technologies 99"), e onde ele define a linguagem usando 
						semântica denotacional (formalismo de cariz funcional utilizado para especificar a sintaxe e a semântica de linguagens - <citref target="Paa95"/>).</p:p>
					<p:p>Depois dum estudo de algumas destas linguagens (em particular todas as que já foram referidas), foi fácil constatar que o XSLT é um denominador comum de 
						uma grande parte delas, aquelas que foram desenvolvidas a pensar em documentos estruturados, tratando-se portanto de uma linguagem específica. 
						Houve, no entanto, uma linguagem que cativou a atenção do autor, pela sua simplicidade e recurso à teoria de conjuntos, a linguagem proposta por 
						Tim Bray <citref target="Bray98"/> na QL'98 - The Query Languages Workshop designada por Element Sets. Um estudo mais atento da linguagem e do seu 
						historial, revelou ser esta a especificação por detrás do conhecido motor de procura Pat comercializado pela OpenText e utilizado na maior parte 
						dos primeiros portais da Internet.</p:p>
					<p:p>Enquanto as linguagens do tipo XSLT assentam numa sintaxe concreta e específica, a Element Sets define uma notação abstracta baseada em cinco operadores 
						da teoria de conjuntos: contido (within), contém (including), união (+), intersecção (^) e diferença (-). Bray argumenta ser capaz de especificar uma 
						grande percentagem de queries que possam ser necessárias num sistema de arquivo documental à custa da combinação daqueles cinco operadores.</p:p>
					<p:p>Numa primeira análise e a título comparativo, apresentam-se a seguir dois exemplos, uma query simples e uma mais complicada que irão ser especificadas 
					respectivamente recorrendo a XSLT e a Element Sets.</p:p>
					<subsubsection>
						<title>Query Simples</title>
						<p:p>Pretende-se seleccionar todos os parágrafos (PARA) pertencentes à introdução (INTROD) que contenham uma ou mais notas de rodapé (FOOTNOTE) ou 
						uma ou mais referências (REF) a outros elementos no documento.</p:p>
						<p:p>Em Element Sets a query seria:</p:p>
						<codeblock>    set1 = Set('PARA') within Set('INTROD')
    set2 = set1 including Set('FOOTNOTE')
    set3 = set1 including Set('REF')
    set4 = (set2 + set3) - (set2 ^ set3)</codeblock>
						<p:p>Apesar de complexa, foi fácil especificar esta query. Bastou excluir (diferença de conjuntos) os elementos resultantes da query anterior que 
						continham ambos os elementos (intersecção de conjuntos), REF e FOOTNOTE.</p:p>
						<p:p>Temos agora, a especificação em XSLT:</p:p>
						<codeblock>    INTROD/PARA[(FOOTNOTE and (not REF))  or (REF and (not FOOTNOTE))]</codeblock>						<p:p></p:p>
					</subsubsection>
					<p:p>Do estudo comparativo realizado entre os dois tipos de linguagem, e do qual os dois exemplos acima fazem parte, podemos concluir que, em termos da 
						operação de selecção, são mais ou menos equivalentes, não se tendo encontrado nenhuma situação que uma solucionasse e a outra não. Vão diferir é no 
						método como fazem a selecção: o XSLT usa a árvore documental e toda a operação de selecção é feita em função dessa estrutura; a Element Sets, por outro 
						lado, não usa a árvore documental, manipula o documento como um conjunto de elementos usando uma sintaxe mais universal. Mas esta diferença existe 
						apenas perante o utilizador que usa a linguagem porque em termos de implementação não se pode fugir às travessias da árvore documental.</p:p>
					<p:p>Ao contrário do que o leitor poderia supor nesta altura, a escolha não recaiu sobre a Element Sets mas sim sobre uma linguagem do tipo XSLT, a XQL - 
						XML Query Language <citref target="RLS98"/>. Os motivos por detrás desta escolha são muito simples. Apesar dos paradigmas, em termos de selecção, 
						serem equivalentes, as linguagens do tipo XSLT vão além da selecção, permitem ter um segundo nível de selecção baseado em restrições sobre o conteúdo.</p:p>
				</subsection>
				<subsection>
					<title>A Linguagem para o Projecto</title>
					<p:p>A linguagem XSLT fornece um método bastante simples para descrever a classe de nodos que se quer seleccionar. É declarativa em lugar de procedimental. 
						Apenas é preciso especificar o tipo dos nodos a procurar usando um tipo de padrões simples baseado na notação de directorias dum sistema de ficheiros 
						(a sua estrutura é equivalente à de uma árvore documental). Por exemplo, livro/autor, significa: seleccionar todos os elementos do tipo autor contidos 
						em elementos livro.</p:p>
					<p:p>A XQL é uma extensão do XSLT. Adiciona operadores para a especificação de filtros, operações lógicas sobre conteúdo, indexação em conjuntos de 
						elementos, e restrições sobre o conteúdo dos elementos. Basicamente, é uma notação para a especificação de operações de extracção de informação de 
						documentos estruturados.</p:p>
					<p:p>Como já foi dito, vamos começar por descrever operadores relacionados com a selecção mas a linha divisória entre selecção e restrição irá sendo 
					diluída ao longo do texto, confundindo-se até, para os casos em que a integração das duas é muito forte.</p:p>
					<subsubsection>
						<title>Padrões e Contexto</title>
						<p:p>Uma expressão de selecção é sempre avaliada em função dum contexto de procura. Um contexto de procura é um conjunto de nodos a que uma 
							expressão se pode aplicar de modo a calcular o resultado. Todos os nodos no contexto de procura são filhos do mesmo nodo pai; o contexto de 
							procura é constituído por todos os nodos que são filhos deste nodo pai e respectivos atributos mais os atributos do nodo pai.</p:p>
						<p:p>As expressões de selecção poderão ser absolutas (o contexto é seleccionado em função do nodo raíz - "/"), ou relativas (o contexto é 
							seleccionado em função do contexto actual - "."). Na especificação do contexto pode ainda ser usado o operador "//" 
							com o significado de descendência recursiva.</p:p>
						<p:p>Exemplos:</p:p>
						<dlist>
							<dt>Seleccionar todos os elementos autor no contexto actual.</dt>
							<dd><inlinecode>./autor</inlinecode> ou <inlinecode>autor</inlinecode></dd>
							<dt>Seleccionar o elemento raíz (report) deste documento.</dt>
							<dd><inlinecode>/report</inlinecode></dd>
							<dt>Seleccionar todos os elementos autor em qualquer ponto do documento actual.</dt>
							<dd><inlinecode>//autor</inlinecode></dd>
							<dt>Seleccionar todos os elementos capítulo cujo atributo tema é igual ao atributo especialidade de report.</dt>
							<dd>capítulo[/report/@especialidade = @tema]</dd>
							<dt>Seleccionar todos os elementos título que estejam um ou mais níveis abaixo do contexto actual.</dt>
							<dd>.//título</dd>
						</dlist>
					</subsubsection>
					<subsubsection>
						<title>Quantificador: todos</title>
						<p:p>O operador "*" quando usado numa expressão de selecção selecciona todos os elementos nesse contexto.</p:p>
						<p:p>Exemplos:</p:p>
						<dlist>
							<dt>Seleccionar todos os elementos filhos de autor.</dt>
							<dd><inlinecode>autor/*</inlinecode></dd>
							<dt>Seleccionar todos os elementos nome que sejam netos de report.</dt>
							<dd><inlinecode>report/*/nome</inlinecode></dd>
							<dt>Seleccionar todos os elementos netos do contexto actual.</dt>
							<dd><inlinecode>*/*</inlinecode></dd>
							<dt>Seleccionar todos os elementos que tenham o atributo identificador.</dt>
							<dd><inlinecode>*[@identificador]</inlinecode></dd>
						</dlist>						
					</subsubsection>
					<subsubsection>
						<title>Atributos</title>
						<p:p>Como já se pôde observar nalguns exemplos, o nome de atributos é precedido por "@". Os atributos são tratados como sub-elementos, 
							imparcialmente, sempre que possível. De notar que os atributos não podem ter sub-elementos pelo que não poderão ter operadores de 
							contexto aplicados ao seu conteúdo (tal resultaria numa situação de erro sintáctico). Os atributos também não têm conceito de ordem, 
							são por natureza anárquicos pelo que nenhum operador de indexação deverá ser-lhes aplicado.</p:p>
						<p:p>Exemplos:</p:p>
						<dlist>
							<dt>Seleccionar o atributo valor no contexto actual.</dt>
							<dd><inlinecode>@valor</inlinecode></dd>
							<dt>Seleccionar o atributo dólar de todos os elementos preço no contexto actual.</dt>
							<dd><inlinecode>preço/@dólar</inlinecode></dd>
							<dt>Seleccionar todos os elementos capítulo que tenham o atributo língua.</dt>
							<dd><inlinecode>capítulo[@língua]</inlinecode></dd>
							<dt>Seleccionar o atributo língua de todos os elementos capítulo.</dt>
							<dd><inlinecode>capítulo/@língua</inlinecode></dd>
							<dt>Exemplo inválido</dt>
							<dd><inlinecode>preço/@dólar/total</inlinecode></dd>
						</dlist>
					</subsubsection>
					<subsubsection>
						<title>Filtro - sub-query</title>
						<p:p>O resultado duma query pode ser refinado através de uma sub-query (restrição aplicada ao resultado da query principal), 
						indicada entre "[" e "]" (nos exemplos anteriores já apareceram várias sem nunca se ter explicado a sua sintaxe e semântica).</p:p>
						<p:p>A sub-query é equivalente à cláusula SQL WHERE. O valor resultante da aplicação de uma sub-query é booleano e os elementos 
							para os quais o valor final seja verdadeiro farão parte do resultado final.</p:p>
						<p:p>Há operadores nas sub-queries que permitem testar o conteúdo de elementos e atributos.</p:p>
						<p:p>Exemplos:</p:p>
						<dlist>
							<dt>Seleccionar todos os elementos capítulo que contenham pelo menos um elemento excerto.</dt>
							<dd><inlinecode>capítulo[excerto]</inlinecode></dd>
							<dt>Seleccionar todos os elementos título pertencentes a elementos capítulo que tenham pelo menos um elemento excerto.</dt>
							<dd><inlinecode>capítulo[excerto]/titulo</inlinecode></dd>
							<dt>Seleccionar todos os elementos autor pertencentes a elementos artigo que tenham pelo menos um elemento excerto, e onde autor tenha email.</dt>
							<dd><inlinecode>artigo[excerto]/autor[email]</inlinecode></dd>
							<dt>Seleccionar todos os elementos artigo que contenham elementos autor com email.</dt>
							<dd><inlinecode>artigo[autor/email]</inlinecode></dd>
							<dt>Seleccionar todos os elementos artigo que tenham um autor e um título.</dt>
							<dd><inlinecode>artigo[autor][titulo]</inlinecode></dd>
						</dlist>						
					</subsubsection>
					<p:p>Como se pode observar nalguns destes exemplos, algumas das restrições que pretendemos colocar sobre os documentos podem ser especificadas com os 
					construtores e operadores já apresentados. A linha divisória entre a selecção e a restrição parece já um pouco diluída.</p:p>
					<subsubsection>
						<title>Expressões booleanas</title>
						<p:p>As expressões booleanas podem ser usadas nas sub-queries e estas, já nos permitem especificar condições contextuais como a restrição de valores a 
						um domínio. Uma expressão booleana tem a seguinte forma:</p:p>
						<codeblock>    val-esquerda operador val-direita</codeblock>
						<p:p>Os operadores são normalmente binários, tomam como argumentos um valor à esquerda e um valor à direita: <b>or</b>, <b>and</b> e <b>not</b> (este é unário tomando o
							valor à direita).</p:p>
						<p:p>Com estes operadores e o agrupamento por parentesis podem especificar-se queries bastante complexas.</p:p>
						<p:p>Exemplos:</p:p>
						<dlist>
							<dt>Seleccionar todos os elementos autor que tenham um email e um url.</dt>
							<dd><inlinecode>autor[email and url]</inlinecode><p:p>No universo das queries, o resultado seria o conjunto de autores que tivessem email e url.</p:p></dd>
							<dt>Seleccionar todos os elementos autor que tenham um email ou um url e pelo menos uma publicação.</dt>
							<dd><inlinecode>autor[(email or url) and publicação]</inlinecode></dd>
							<dt>Seleccionar todos os elementos autor que tenham um email e nenhuma publicação.</dt>
							<dd><inlinecode>autor[email and not publicação]</inlinecode></dd>
							<dt>Seleccionar todos os elementos autor que tenham pelo menos uma publicação e não tenham email nem url.</dt>
							<dd><inlinecode>autor[publicação and not (email or url)]</inlinecode></dd>
						</dlist>						
					</subsubsection>
					<subsubsection>
						<title>Equivalência</title>
						<p:p>A igualdade é notada por <inlinecode>=</inlinecode> e a desigualdade por <inlinecode>!=</inlinecode>.</p:p>
						<p:p>Podemos usar strings nas expressões desde que limitadas por aspas simples ou duplas.</p:p>
						<p:p>Exemplos:</p:p>
						<dlist>
							<dt>Seleccionar todos os autores que têm o sub-elemento organização preenchido com o valor 'U.Minho'.</dt>
							<dd><inlinecode>autor[organização = 'U.Minho']</inlinecode></dd>
							<dt>Seleccionar todos os elementos que têm o atributo língua preenchido com o valor 'pt'.</dt>
							<dd><inlinecode>*[@língua = 'pt']</inlinecode></dd>
						</dlist>
					</subsubsection>		
					<p:p>A linguagem possui todos os operadores relacionais habituais, cuja utilização não foi aqui exemplificada, 
						porém, a sua semântica é bem conhecida e este enunciado já tem complexidade qb. Fica ao critério dos grupos de trabalho a sua implementação.</p:p>
				</subsection>
				
			</section>
			
			
		</chapter>
		
		<chapter>
			<title>Enunciado 3 - Yet Another Top-Down Parser Generator</title>
			<p:p>Neste projecto, pretende-se que o aluno construa um gerador de parsers segundo a filosofia Top-Down. Nesse sentido,
			será necessário definir uma linguagem para a especificação de gramáticas e todos os algoritmos que verificam se uma
			gramática especificada pode ser processada pela ferramenta (se é LL(1)), e neste caso gerem o código necessário para 
			implementar o parser.</p:p>
			<p:p>Alternativamente poderão usar uma abordagem Bottom-Up com as devidas validações: LR0, SLR1, LALR.</p:p>
		</chapter>
		
	</body>
	<backmatter> 
		<bibliography>
			<bibitem type="book" id="Bray98">
				<citkey>Bray98</citkey>
				<citation>RDF and Metadata, Tim Bray, Seybold and O'Reilly Publicatons, June 1997.</citation>
			</bibitem>
			
			<bibitem type="website" id="Cla96">
				<citkey>Cla96</citkey>
				<citation>"DSSSL - Document Style and Semantics Specification Language", Editado por James Clark em 1996: http://www.jclark.com/dsssl</citation>
			</bibitem>
			<bibitem type="inproceedings" id="CCDFPT98">
				<citkey>CCDFPT98</citkey>
				<citation>XML-GL: A Graphical Language for Querying and Reshaping XML Documents, Stefano Ceri, Sara Comai, Ernesto Damiani, Piero Fraternali, 
					Stefano Paraboschi, e Letizia Tanca, QL'98 - The Query Languages Workshop, December 5, 1998.</citation>
			</bibitem>
			<bibitem type="inproceedings" id="DeR98">
				<citkey>DeR98</citkey>
				<citation>XQuery: A unified syntax for linking and querying general XML documents, Steven DeRose, QL'98 - 
					The Query Languages Workshop, December 5, 1998.</citation>
			</bibitem>
			<bibitem type="article" id="Paa95">
				<citkey>Paa95</citkey>
				<citation>Attribute Grammars Paradigms: A High-Level Methodology in Language Implementation, Jukka Paakki, 
					ACM Computing Serveys, 27, 2, June 1995.</citation>
			</bibitem>
			<bibitem type="inproceedings" id="RLS98">
				<citkey>RLS98</citkey>
				<citation>XML Query Language (XQL), Jonathan Robie, Joe Lapp, e David Schach, QL'98 - The Query Languages 
					Workshop, December 5, 1998.</citation>
			</bibitem>
			<bibitem type="inproceedings" id="Tom98">
				<citkey>Tom98</citkey>
				<citation>Providing flexible access in a query language for XML, Frank Tompa, QL'98 - The Query Languages 
					Workshop, December 5, 1998.</citation>
			</bibitem>
			<bibitem type="inproceedings" id="Wad99">
				<citkey>Wad99</citkey>
				<citation>A formal semantics of patterns in XSLT, Philip Wadler, Markup Technologies'99, Philadelphia - USA, Dec. 1999.</citation>
			</bibitem>
			<bibitem type="inproceedings" id="Wid98">
				<citkey>Wid98</citkey>
				<citation>Querying XML with Lore, Jennifer Widom, QL'98 - The Query Languages Workshop, December 5, 1998.</citation>
			</bibitem>
			<bibitem type="website" id="XSL">
				<citkey>XSL</citkey>
				<citation>"Extensible Stylesheet Language (XSL) Version 1.0" - World Wide Web Consortium Working Draft 18-August-1998.</citation>
			</bibitem>
			<bibitem type="website" id="XSLT">
				<citkey>XSLT</citkey>
				<citation>"XSL Transformations (XSLT) - Version 1.0" - World Wide Web Consortium Recommendation 16-November-1999.</citation>
			</bibitem>
			
		</bibliography>
	</backmatter>

</r:report>
